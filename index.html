<!DOCTYPE html>
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1">
<style>
* {
  box-sizing: border-box;
}

/* Add a gray background color with some padding */
body {
  font-family: Arial;
  padding: 20px;
  background: #f1f1f1;
}

/* Header/Blog Title */
.header {
  padding: 30px;
  font-size: 40px;
  text-align: center;
  background: white;
}

/* Create two unequal columns that floats next to each other */
/* Left column */
.leftcolumn {   
  float: left;
  width: 75%;
}

/* Right column */
.rightcolumn {
  float: left;
  width: 25%;
  padding-left: 20px;
}

/* Fake image */
.fakeimg {
  background-color: #aaa;
  width: 100%;
  padding: 20px;
}

/* Add a card effect for articles */
.card {
   background-color: white;
   padding: 20px;
   margin-top: 20px;
}

/* Clear floats after the columns */
.row:after {
  content: "";
  display: table;
  clear: both;
}

/* Footer */
.footer {
  padding: 20px;
  text-align: center;
  background: #ddd;
  margin-top: 20px;
}

/* Responsive layout - when the screen is less than 800px wide, make the two columns stack on top of each other instead of next to each other */
@media screen and (max-width: 800px) {
  .leftcolumn, .rightcolumn {   
    width: 100%;
    padding: 0;
  }
}
</style>
</head>
<body>

<div class="header">
  <h2>Sistemas Distribuídos : Trabalho Prático</h2>
</div>

<div class="row">
  <div class="leftcolumn">
    <div class="card">
      <h2>Simulador SMPL : Algoritmo VRing</h2>
      <h3>Tarefa 0 : </h3>
      <p> Digitar, compilar e executar o programa exemplo, tempo.c </p>
      <p>-> Foi compilado o programa usando o makefile e executado o programa com ./tempo 3 </p>
      
      <h3>Tarefa 1 :</h3>
      <p>Fazer cada um dos processos testar o seguinte no anel. Implemente o teste com a função status() do SMPL e imprimir (printf) o resultado de cada teste executado. Por exemplo: “O processo i testou o processo j correto no tempo tal.” 
        <br>Foi acrescentado no case test um printf mostrando o teste correto do processo i no j (incrementando o token):  </p>
        
        <p>case test: 

            if (status(processo[token].id) != 0) // processo falho não testa 

                break; 

            printf("O processo %d vai testar no tempo %4.1f\n", token, time()); 

            schedule(test, 30.0, token); // um novo teste daqui a esse tempo 

            printf("O processo %d testou o processo %d correto no tempo %4.1f\n", token, (token+1)%N, time()); 

            break; </p>
      <p> Log de saída : </p>
        <h3>Tarefa 2 :</h3>
      <p> Cada processo correto executa testes até achar outro processo correto. Lembre-se de tratar o caso em que todos os demais processos estão falhos. Imprimir os testes e resultados.
        <br>Foram feitas as seguintes alterações mostradas com comentários no case test :</p>  
        
        <p>-> Acrescentando uma falha e recuperação do processo 2 além do 1 para teste :  

        schedule(fault, 31.0, 2);  // vai falhar nesse tempo 

        schedule(recovery, 61.0, 2); // vai recuperar nesse tempo  </p>
      <p> Saída : </p>
        <h3>Tarefa 3 : </h3>
      <p> Cada processo mantém localmente o vetor State[N]. A entrada do vetor State[j] indica o estado do processo j. O estado de cada processo pode ser: -1 (unknown), 0 (correto) ou 1 (falho). Inicialize (para todos os processos) o State[N] com -1 (indicando estado “unknown”) para todos os demais processos e 0 para o próprio processo. Nesta tarefa ao executar um teste em um processo j, o testador atualiza a entrada correspondente no vetor State[j]. Em cada intervalo de testes, mostre o vetor State[N].
        <br>Foram feitas as seguintes alterações no case test tratando os estados (-1,0,1) e os possíveis eventos que podem ocorrer:
        </p>
      
        <p> case test: 

            if (status(processo[token].id) != 0) // processo falho não testa 

                break; 

            printf("O processo %d vai testar no tempo %4.1f\n", token, time()); 

            int t = (token+1)%N; // já que é um teste circular faço mod N 

  

            while (status(processo[t].id) != 0 && t != token){  // enquanto não acha um correto e não testou todos 

                printf("O processo %d testou o processo %d falho no tempo %4.1f\n", token, t, time()); 

                // tratando eventos 

                if (processo[token].State[t] == -1) // se em estado unknown 

                    processo[token].State[t] = 1; // atualiza para estado falho 

                else if (processo[token].State[t]%2 == 0) // se par (Era correto e agora é falho -> evento) 

                    processo[token].State[t]++; // incrementa 

                t = (t+1)%N; // vai para o proximo processo considerando que é um teste circular             

            }        

             

            // tratando eventos 

            if (processo[token].State[t] == -1) // se em estado unknown 

                processo[token].State[t] = 0; // atualiza para estado correto 

            else if (processo[token].State[t]%2 == 1) // se ímpar (Era falho e agora é correto -> evento)       

                processo[token].State[t]++; // incrementa 

            printf("O processo %d testou o processo %d correto no tempo %4.1f\n", token, t, time());                

            printf("Vetor State resultante do processo %d: ", token); // mostra o vetor State 

            for(int j=0; j<N; j++){ 

                printf("%d ", processo[token].State[j]); 

            } 

            printf("\n"); 


            schedule(test, 30.0, token); // um novo teste daqui a esse tempo 

            break; </p>
        
        <p>Log da saída :</p>
        
        <p> -> Acrescentando uma falha e recuperação do processo 2 além do 1 para teste :  

          schedule(fault, 31.0, 2);  // vai falhar nesse tempo 

          schedule(recovery, 61.0, 2); // vai recuperar nesse tempo </p>
      
         <p>Log da saída :</p>
      
        <h3>Tarefa 4</h3>
      <p>Quando um processo correto testa outro processo correto obtém as informações de diagnóstico do processo testado sobre todos os processos do sistema exceto aqueles que testou nesta rodada, além do próprio testador. 
        <br>
        Através de um laço for acrescentado fora do laço de repetição while, para os testes corretos, é possivel salvar as informações fazendo uma cópia do vetor state : 

        for (int j=(t+1)%N; j != token; j=(j+1)%N){  // copia o vetor state atualizando as informações do processo que esta testando sobre os demais que não foram testados na rodada 

               processo[token].State[j] = processo[t].State[j];             

        } 
      </p>
       <p>Log da saída :</p>
       <p> -> Acrescentando uma falha e recuperação do processo 2 além do 1 para teste :  

          schedule(fault, 31.0, 2);  // vai falhar nesse tempo 

          schedule(recovery, 61.0, 2); // vai recuperar nesse tempo </p>
      
      <p>Log da saída :</p>
      
      

</body>
</html>
